## Chapter 13 questions

1. Explain the following expressions.

```c
/* key
#=> returns
p   pointer
fn  function */

int     abc();              // fn #=> int (8)
int     abc[3];             // array of three ints
int     **abc();            // fn #=> p to a p to int
int     (*abc)();           // p to a function #=> int
int     (*abc)[6];          // p to array of six integers
int     *abc();             // fn #=> p to int
int     **(*abc[6])();      // array of six ps functions
                            // #=> ps to ps to ints (whew!)
int     *(*abc[6]);         // array of six ps to ps to ints
int     *(*abc())();        // illegal
int     (**(*abc)())();     // p to fn #=> p to p to function #=> int
int     (*(*abc)())[6];     // p to fn #=> p to array of 6 ints
int     *(*(*(*abc)())[6]); // p to fn #=> p to array of 6 p to p to int
```

2. Given

```c
char     *array[10];      // array of 10 p to char
char     **ptr = array;   // pointer to pointer to array of 10 p to char
```

what is effect of adding one to `ptr`?

we are storing the rvalue of the expression `array` into a variable that is a
pointer to a pointer to a char. First, we determine the rvalue of array by
looking at its declaration. we see that it is an uninitialized array of 10
pointers to chars. Its r-value is the address at which the first pointer is
stored, i.e. &array[0]

adding one to `ptr` thus increments the memory address that `ptr` points to by
sizeof(&array[0]).

3. what is the type of the arg to this fn?

`void func(int ***arg);`

it's a pointer to pointer to a pointer to an int. it looks like this

arg --> ptr1 --> ptr2 --> int arg_value;

4. how to improve this junk

```c
Trx *t;

t->product->orders += 1;
t->product->qty_oh -= t->qty;
t->product->supplier->reorder_qty += t->qty;
if (t->product->restricted) {
  // blah blah blah
}```
